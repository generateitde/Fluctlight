<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Neural Sphere Shader Audio Reactive</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#02040a; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display: flex; gap: 10px; align-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(200,220,255,0.95);
      user-select: none;
    }
    button {
      border: 1px solid rgba(120,160,255,0.35);
      background: rgba(10,20,40,0.55);
      color: rgba(220,235,255,0.95);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }
    #status { font-size: 12px; opacity: 0.9; max-width: 62vw; line-height: 1.25; }
    #hint {
      position: fixed; left: 12px; bottom: 12px; z-index: 10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 12px; opacity: 0.75; color: rgba(200,220,255,0.9);
      max-width: 92vw; line-height: 1.35;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="micBtn">Start Mic</button>
    <button id="pauseBtn">Pause</button>
    <div id="status">Ready. Für Mic: HTTPS nötig, speziell auf iOS. Erst Button tippen.</div>
  </div>
  <div id="hint">
    Sprich ins Mikro. Lautstärke + Tonhöhe treiben jetzt wellenförmige Peaks nach außen.
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x02040a);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 3.8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const N = isMobile ? 30000 : 50000;
    const radius = 0.88;

    function randInSphere() {
      while (true) {
        const x = (Math.random()*2 - 1) * radius;
        const y = (Math.random()*2 - 1) * radius;
        const z = (Math.random()*2 - 1) * radius;
        const r = Math.hypot(x,y,z);
        if (r <= radius) return {x,y,z,r};
      }
    }

    const pos = new Float32Array(N*3);
    const rn = new Float32Array(N);
    const seed = new Float32Array(N);

    for (let i=0; i<N; i++) {
      const p = randInSphere();
      pos[3*i+0] = p.x;
      pos[3*i+1] = p.y;
      pos[3*i+2] = p.z;
      rn[i] = p.r / radius;
      seed[i] = Math.random();
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geom.setAttribute("aRn", new THREE.BufferAttribute(rn, 1));
    geom.setAttribute("aSeed", new THREE.BufferAttribute(seed, 1));

    const E = 12;
    const emitters = new Float32Array(E*3);

    function resetEmitters() {
      for (let i=0; i<E; i++) {
        const p = randInSphere();
        const s = 0.75;
        emitters[3*i+0] = p.x*s;
        emitters[3*i+1] = p.y*s;
        emitters[3*i+2] = p.z*s;
      }
    }
    resetEmitters();

    let audioCtx = null;
    let analyser = null;
    let freqData = null;
    let timeData = null;

    let audioRMS = 0.0;
    let audioCentroid = 0.0;
    let audioPulse = 0.0;
    let band0 = 0.0;
    let band2 = 0.0;

    const statusEl = document.getElementById("status");
    const micBtn = document.getElementById("micBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    let paused = false;
    let micActive = false;
    let visualAmp = 0.0;

    micBtn.addEventListener("click", async () => {
      try {
        await startMic();
        micActive = true;
        micBtn.textContent = "Mic aktiv";
        statusEl.textContent = "Mic läuft. Sprich jetzt – die Wellen reagieren direkt auf Lautstärke und Tonhöhe.";
      } catch (e) {
        statusEl.textContent = "Mic Fehler: " + (e?.message || String(e));
      }
    });

    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
    });

    async function startMic() {
      if (micActive && analyser) return;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      statusEl.textContent = "Mic verbunden. Sprich ins Mikro…";

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      });
      const src = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.58;
      analyser.minDecibels = -92;
      analyser.maxDecibels = -18;
      src.connect(analyser);

      freqData = new Uint8Array(analyser.frequencyBinCount);
      timeData = new Uint8Array(analyser.fftSize);

      if (audioCtx.state === "suspended") await audioCtx.resume();

      statusEl.textContent = "Mic verbunden. Sprich ins Mikro…";
    }

    const clamp01 = (x) => Math.min(1, Math.max(0, x));

    function avg(arr, a, b) {
      let s = 0;
      const n = Math.max(1, b - a);
      for (let i=a; i<b; i++) s += arr[i];
      return s / n;
    }

    function updateAudio() {
      if (!analyser) {
        audioRMS *= 0.96;
        audioCentroid *= 0.96;
        audioPulse *= 0.96;
        band0 *= 0.96;
        band2 *= 0.96;
        return;
      }

      analyser.getByteFrequencyData(freqData);
      analyser.getByteTimeDomainData(timeData);

      let sumSq = 0;
      for (let i=0; i<timeData.length; i++) {
        const v = (timeData[i] - 128) / 128;
        sumSq += v*v;
      }
      const rms = Math.sqrt(sumSq / timeData.length);
      audioRMS = 0.85*audioRMS + 0.15*rms;

      let magSum = 0;
      let weighted = 0;
      for (let i=0; i<freqData.length; i++) {
        const m = freqData[i] / 255;
        magSum += m;
        weighted += m * i;
      }
      const centroid = (magSum > 1e-6) ? (weighted / magSum) / freqData.length : 0;
      audioCentroid = 0.85*audioCentroid + 0.15*centroid;

      const n = freqData.length;
      const b0 = avg(freqData, 2, Math.floor(n*0.10));
      const b2 = avg(freqData, Math.floor(n*0.35), Math.floor(n*0.85));
      band0 = 0.85*band0 + 0.15*clamp01(b0/255);
      band2 = 0.85*band2 + 0.15*clamp01(b2/255);

      let low = 0;
      const lowBins = Math.max(8, Math.floor(n*0.08));
      for (let i=0; i<lowBins; i++) low += (freqData[i] / 255);
      low /= lowBins;
      const p = clamp01(low * 1.6);
      audioPulse = Math.max(audioPulse * 0.92, p);
    }

    const vertexShader = `
      precision highp float;

      attribute float aRn;
      attribute float aSeed;

      uniform float uTime;
      uniform float uAmp;
      uniform float uBright;
      uniform float uBand0;
      uniform float uBand2;
      uniform float uPulse;
      uniform float uMorph;

      uniform vec3 uEmitters[${E}];

      varying float vIntensity;
      varying float vRn;
      varying float vSeed;

      float hash13(vec3 p) {
        p = fract(p * 0.1031);
        p += dot(p, p.yzx + 33.33);
        return fract((p.x + p.y) * p.z);
      }

      void main() {
        vRn = aRn;
        vSeed = aSeed;

        vec3 p = position;
        vec3 dir = normalize(p + vec3(0.0001));

        float kShell = 7.5 + 8.0 * uBright;
        float shellSpeed = 0.35 + 1.8 * uAmp;
        float base = 0.20
          + 0.55 * pow(vRn, 0.60)
          + 0.18 * exp(-pow(vRn / 0.22, 2.0));

        float wave = 0.5 + 0.5 * sin(6.2831853 * (kShell * vRn - shellSpeed * uTime + vSeed * 0.35));
        float envelope = exp(-pow((vRn - 0.55) / 0.28, 2.0));
        float shellStrength = 0.14 + 0.85 * uAmp;

        float intensity = base * (0.85 + shellStrength * (wave - 0.5) * envelope);

        float pitchGain = 0.45 + 1.55 * uBright;
        float spikeDrive = clamp(0.1 + 1.05 * uAmp + 0.55 * uBand2 + 0.35 * uPulse, 0.0, 1.7);
        float n1 = hash13(dir * (8.0 + uMorph * 4.0) + vec3(vSeed * 11.0, uTime * 0.19, uMorph));
        float n2 = hash13(dir.zyx * (13.0 + uMorph * 2.5) + vec3(uTime * 0.27, vSeed * 17.0, 1.7 + uMorph));
        float randomMask = pow(clamp(0.56 * n1 + 0.44 * n2, 0.0, 1.0), 3.8 - 2.0 * clamp(uAmp + 0.35 * uBand2, 0.0, 1.0));

        float radialWave = 0.5 + 0.5 * sin(
          (12.0 + 14.0 * pitchGain) * vRn
          - uTime * (2.2 + 4.6 * uAmp + 1.4 * uBand2)
          + (vSeed * 8.0 + n1 * 4.0)
        );

        float outerBias = smoothstep(0.16, 0.98, vRn);
        float spikeEnvelope = pow(radialWave, 1.2 + 2.4 * uBright) * outerBias;
        float spikeAmount = (0.03 + 0.24 * spikeDrive * spikeEnvelope) * (0.45 + 1.45 * randomMask);

        p += dir * spikeAmount;
        intensity += clamp(spikeAmount * (1.1 + 1.2 * uBright), 0.0, 0.9);

        float emitterGain = 0.25 + 1.4 * uBand0;
        float cluster = 0.0;

        for (int i=0; i<${E}; i++) {
          vec3 e = uEmitters[i];
          float d = length(p - e);
          float dn = d / 1.2;

          float localPhase = (dn * 9.0 - uTime * (0.8 + float(i) * 0.07) + vSeed * 6.0);
          float localWave = 0.5 + 0.5 * sin(localPhase * 2.2);
          float localEnv = exp(-pow((dn - 0.35) / 0.22, 2.0));

          cluster += localWave * localEnv;
        }
        cluster *= (1.0 / float(${E}));

        intensity += emitterGain * uAmp * cluster;

        float shimmerGain = 0.15 + 1.1 * uBand2;
        float shimmer = 0.2 + 0.8 * sin(uTime * 8.0 + vSeed * 6.0);
        intensity += shimmerGain * shimmer * (0.15 + 0.35 * uBand2) * (0.3 + 0.7 * envelope);

        float beat = clamp(uBand0 + 0.45 * uPulse, 0.0, 1.0);
        float breathe = 0.92 + 0.18 * smoothstep(0.1, 0.8, beat);
        intensity *= breathe;

        vIntensity = clamp(intensity, 0.0, 1.0);

        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        float size = ${isMobile ? "6.5" : "5.5"};
        size *= (0.80 + 0.55 * uAmp + 0.22 * uPulse);
        gl_PointSize = size * (1.0 / -mvPosition.z);

        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    const fragmentShader = `
      precision highp float;

      uniform float uBright;
      uniform float uBand0;
      uniform float uBand2;
      uniform float uPulse;

      varying float vIntensity;
      varying float vRn;
      varying float vSeed;

      void main() {
        vec2 uv = gl_PointCoord * 2.0 - 1.0;
        float r2 = dot(uv, uv);

        float disc = exp(-r2 * 3.2);
        float core = exp(-r2 * 14.0);

        float intensity = vIntensity;
        float hueMix = clamp(0.15 + 0.9 * uBright + 0.35 * uBand2, 0.0, 1.0);
        vec3 cool = vec3(0.06, 0.38, 1.0);
        vec3 violet = vec3(0.50, 0.22, 1.0);
        vec3 warm = vec3(0.98, 0.48, 0.26);
        vec3 baseColor = mix(cool, violet, hueMix);
        baseColor = mix(baseColor, warm, clamp(0.65 * uPulse + 0.35 * uBand0, 0.0, 1.0));

        float seedTint = 0.4 + 0.6 * sin(vSeed * 31.0 + vRn * 12.0);
        vec3 col = (0.08 + 1.05 * intensity) * baseColor;
        col *= mix(vec3(0.78, 0.86, 1.0), vec3(1.0, 0.86, 0.95), seedTint);

        float sparkle = 0.08 * sin(vSeed * 437.0 + vRn * 19.0);
        col += sparkle * vec3(0.04, 0.05, 0.10);

        float alpha = clamp(disc * (0.35 + 0.95 * intensity) + core * 0.25, 0.0, 1.0);

        if (r2 > 1.0) discard;

        gl_FragColor = vec4(col, alpha);
      }
    `;

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0.0 },
        uAmp: { value: 0.0 },
        uBright: { value: 0.0 },
        uBand0: { value: 0.0 },
        uBand2: { value: 0.0 },
        uPulse: { value: 0.0 },
        uMorph: { value: Math.random() },
        uEmitters: { value: new Array(E).fill(0).map((_,i)=> new THREE.Vector3(
          emitters[3*i+0], emitters[3*i+1], emitters[3*i+2]
        )) }
      }
    });

    const points = new THREE.Points(geom, material);
    scene.add(points);

    const linkCount = isMobile ? 5000 : 9000;
    const linkPos = new Float32Array(linkCount * 2 * 3);
    for (let i=0; i<linkCount; i++) {
      const ai = (Math.random() * N) | 0;
      const bi = (Math.random() * N) | 0;
      linkPos[i*6+0] = pos[3*ai+0];
      linkPos[i*6+1] = pos[3*ai+1];
      linkPos[i*6+2] = pos[3*ai+2];
      linkPos[i*6+3] = pos[3*bi+0];
      linkPos[i*6+4] = pos[3*bi+1];
      linkPos[i*6+5] = pos[3*bi+2];
    }

    const linkGeom = new THREE.BufferGeometry();
    linkGeom.setAttribute("position", new THREE.BufferAttribute(linkPos, 3));
    const linkMat = new THREE.LineBasicMaterial({
      color: 0x6fb4ff,
      transparent: true,
      opacity: 0.12,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const links = new THREE.LineSegments(linkGeom, linkMat);
    scene.add(links);

    addEventListener("pointerdown", (ev) => {
      if (ev.target instanceof HTMLButtonElement) return;
      resetEmitters();
      for (let i=0; i<E; i++) {
        material.uniforms.uEmitters.value[i].set(
          emitters[3*i+0], emitters[3*i+1], emitters[3*i+2]
        );
      }
      statusEl.textContent = "Emitter neu verteilt. Sprich weiter.";
    });

    let t = 0;
    let morph = Math.random();
    function animate() {
      requestAnimationFrame(animate);
      if (paused) return;

      t += 0.012;
      updateAudio();

      const ampTarget = clamp01(audioRMS * 5.0 + band0 * 0.9 + audioPulse * 0.7);
      visualAmp = 0.72 * visualAmp + 0.28 * ampTarget;
      const amp = clamp01(visualAmp);
      const bright = clamp01(audioCentroid * 1.5 + band2 * 0.35);

      material.uniforms.uTime.value = t;
      material.uniforms.uAmp.value = amp;
      material.uniforms.uBright.value = bright;
      material.uniforms.uBand0.value = clamp01(band0);
      material.uniforms.uBand2.value = clamp01(band2);
      material.uniforms.uPulse.value = clamp01(audioPulse);
      morph = (morph + 0.008 + 0.03 * amp + 0.02 * bright) % 1.0;
      material.uniforms.uMorph.value = morph;

      points.rotation.y += 0.0016;
      points.rotation.x += 0.0006;
      links.rotation.copy(points.rotation);
      linkMat.opacity = 0.07 + 0.26 * amp + 0.10 * bright;

      renderer.render(scene, camera);
    }
    animate();

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });
  </script>
</body>
</html>
